---
title: "AnalyzAIRR"
author:
- name: V. Mhanna, G. Pires, G. Bohl, K. El Soufi, <br> N. Tchitchek, D. Klatzmann, A. Six, E. Mariotti-Ferrandiz
  affiliation: Sorbonne UniversitÃ©, INSERM, Immunology-Immunopathology-Immunotherapy (i3), Paris, France
- name: H. P. Pham
  affiliation: Parean Biotechnologies

output: 
  #rmarkdown::html_document:
    rmdformats::robobook:
    #toc: true
    toc_depth: 2
    #theme: cerulean
    highlight: tango
    use_bookdown: true
    css: styles.css
package: AnalyzAIRR
vignette: >
  %\VignetteIndexEntry{AnalyzAIRR- Comprehensive AIRR data analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


<style type="text/css">
<!-- div#TOC li { -->
<!--     list-style:none; -->
<!--     background-image:none; -->
<!--     background-repeat:none; -->
<!--     background-position:0;  -->
<!-- } -->
 .book .book-body .page-inner  { 
    max-width: 1400px; 
 <!-- width: 120%;  -->
 } 
 .column-left {
  float: left;
  width: 49.7%;
}
.column-right{
 float: right;
  width: 49.7%;
}
.col2 {
    columns: 2 200px;         /* number of columns and width in pixels*/
    -webkit-columns: 2 200px; /* chrome, safari */
    -moz-columns: 2 200px;    /* firefox */
  }
h1 {
  color: #033c73;
   font-size: 30px;
}
h1.title {
  color: #033c73;
}
h2 {
  color: #033c73;
  font-size: 24px;
}
h3 {
   color: #033c73;
   font-size: 18px;
}
h4 {
   color: #022f5a;
}
h5 {
  color: #033c73;
}
h6 {
   color: #033c73;
}
body{ 
  font-size: 14px;
}
p.caption {
  font-size: 0.9em;
  font-style: italic;
  color: grey;
  margin-right: 10%;
  margin-left: 10%;
  text-align: justify;
}
em { 
font-weight: normal; font-style: italic; font-size: 0.9em;
}
em.special { 
color: grey; 
}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
'%>%' <-  kableExtra::'%>%'

```
# Introduction

**AnalyzAIRR** is an R package developed to analyze bulk Ig/TCR repertoire datasets.

* It can be used by both biologists and bioinformaticians.

* It proposes an analytical routine starting with data exploration, leading to in-depth statistical comparisons with the aim of answering defined biological questions.

* It allows the calculation of a set of diversity measures and statistical metrics applicable at any level of granularity.

* It offers different types of data visualization and ready-to-publish graphics that can be easily personalized. 

This guide provides an overview of the pipeline proposed in **AnalyzAIRR**.

# Installation
The latest release of **AnalyzAIRR** can be installed from Github using **devtools**:
```{r github1, echo = TRUE, eval = FALSE}
install.packages("devtools")  
devtools::install_github("vanessajmh/AnalyzAIRR")
```
Load the **AnalyzAIRR** package
```{r load library, echo=T, eval=T, warning=F, message=F}
library(AnalyzAIRR)
```

# Getting started

## Data loading

**AnalyzAIRR** proposes two different data loading processes depending on the alignment files format. 

### Use input files in AnalyzAIRR-supported formats

**1. Specify the paths to input files**

  **AnalyzAIRR** supports the following formats:
  
  * **MiXCR**: https://github.com/milaboratory/mixcr

  * **immunoSEQ**: https://www.immunoseq.com/

  * **MiAIRR**: https://docs.airr-community.org/en/latest/datarep/rearrangements.html 
  
All needed is to specify the list of paths to the alignement files.

A list of 8 samples were selected from a published study (Mhanna et al., 2021) to illustrate the use of this package. Fastq files were aligned using MiXCR and can be found at https://github.com/tchitchek-lab/RepSeq/extdata/mixcr


```{r load aligned files, echo=T, eval=T}
l <- list.files(system.file(file.path('extdata/mixcr'),
                            package='AnalyzAIRR'),
                            full.names = T)
```
```{r show path, echo=F, eval=T}
l
```

**2. Load the metadata**

  It is possible to provide a metadata if users wish to perform inter-group comparative analyses. 
  
  The metadata should be provided as a dataframe containing:

  * a column with the sample names that match the name of the alignment files and their order in the list.

  Only one column containing the sample names should be provided in the metadata file. This column is assigned to the `row.names` argument when loading the metadata. 

  * any additional columns with relevant information for the analyses. Columns could encompass the experimental conditions, clinical variables, etc... 
  
  No specific column names nor order are required.
  
  **Note**: Since **R 4.0.0**, *stringsAsFactors* is set to **FALSE** by default, user will thus need to coerce character vectors into factors.


```{r load metadata}
metadata <- read.table(system.file(file.path('extdata/sampledata.txt'),
                            package='AnalyzAIRR'), 
                            header=T,
                            row.names = 1)
metadata$cell_subset <- factor(metadata$cell_subset)
metadata$sex <- factor(metadata$sex)
```

```{r view metadata, echo=F}

knitr::kable(metadata) %>%
    kableExtra::kable_styling(
                    full_width = FALSE,
                    position = "left",
                    font_size = 10) %>%
  kableExtra::row_spec(0, color="#022f5a", font_size = 12)

```

**3. Load the files**

Alignment files can be loaded using the `readAIRRSet()` function. 

To do so, the following parameters must be specified:

 * `fileList`: The list of paths to the input files. File extensions can be one of the following: .tsv, txt.gz, .zip, .tar
 
 * `fileFormat`: The name of the tool that was used to generate the alignment files. Should be one of "MiXCR", "immunoseq" or "MiAIRR".
 
 * `chain`: The chain type to be analyzed. Should be one of the following:
   - "TRA", "TRB","TRG" or "TRD" for the TCR repertoires
   - "IGH","IGK" or "IGL" for the BCR repertoires
   
  Only a single chain can be loaded at once. 
 
 
 * `sampleinfo`: A dataframe with the metadata information
 
 * `keep.ambiguous`: A choice whether ambiguous sequences should be left in the datasets
 
 * `keep.unproductive`: A choice whether unproductive sequences should be left in the datasets
 
 * `filter.singletons`: A choice whether sequences with an occurrence of 1 should be filtered out
  
 * `aa.th`: A threshold determining the CDR3 amino acid sequence length limits. Refer to the function's documentation for more details
 
 * `outFiltered`: A choice whether to write an output file containing the filtered out reads by the previously cited filtering parameters
 
 * `raretab`: A choice whether a rarefaction table should be generated
 
 * `cores`: The number of CPU cores to be used for a parallel processing
 
It is possible to apply the above-mentioned filtering functions subsequently to the data loading step in case users wish to explore the datasets before any data manipulation.


```{r data loading, echo=T, eval=T}
RepSeqData <- readAIRRSet(fileList = l,
                          fileFormat = "MiXCR",
                          chain = "TRA",
                          sampleinfo = metadata,
                          keep.ambiguous = FALSE,
                          keep.unproductive=FALSE,
                          filter.singletons=FALSE,
                          aa.th=8,
                          outFiltered=TRUE,
                          raretab=FALSE,
                          cores=1L)


```

### Use files having a compatible format

**AnalyzAIRR** offers the possibility to load alignment files in other formats than the ones cited in the previous section. These files should however fulfill some requirements.

**1. Required column names**

Alignment files should contain the following required column names:

- **sample_id**: Sample names

- **CDR3nt**: CDR3 nucleotide sequence

- **CDR3aa**: CDR3 amino acid sequence

- **V**: Variable gene name (IMGT nomenclature)

- **J**: Joining gene name (IMGT nomenclature)

- **count**: the occurrence of each sequence within the sample

**Note**: The order of the columns must be respected. Input files can contain additional columns that will not be taken into account during the loading process.

**2. Load the files**

`readFormatSet()` is the equivalent function of `readAIRRSet()` when using user-formatted files. It allows the loading and filtering of a list of files using the same previously described parameters.

## The RepSeqExperiment object

### Architecture

Data loading with either one of `readFormatSet()` or `readAIRRSet()` allows the generation of a RepSeqExperiment object. This object is used as input in all of the functions.

It is composed of 4 slots, each containing a different type of information.

+ **assayData**: a data.table composed of all the alignment datasets and containing the following columns:

    - **sample_id**: Sample names

  - **CDR3nt**: CDR3 nucleotide sequence

  - **CDR3aa**: CDR3 amino acid sequence

  - **V**: Variable gene name

  - **J**: Joining gene name

  - **VJ**: V-J gene combination using V and J gene names.

  - **clone**: The sequence including the V gene, the amino acid CDR3 sequence and the J gene

  - **clonotype**: The sequence of the clone as well as the nucleotide CDR3 sequence

  - **count**: the occurrence of each sequence

This slot can be extracted using the `assay()` function.

```{r assay,  echo = T, eval=F}
assay(RepSeqData)
```

```{r view assay,  echo = F}
knitr::kable(head(assay(RepSeqData))) %>% 
    kableExtra::kable_styling(bootstrap_options = "condensed", 
                     full_width = F, 
                     position = "left",
                     font_size = 10) %>%
  kableExtra::row_spec(0, color="#022f5a",  font_size = 12)
```

+ **metaData**: a data frame containing the metadata information provided for the building of the RepSeqExperiment object, followed by a number of statistics calculated for each sample.

  These statistics include:
  
    * **nSequences**: the total number of sequences in a sample

  * **CDR3nt**: the number of unique nucleotide CDR3s

  * **CDR3aa**: the number of unique amino acid CDR3s

  * **V**: the total number of V genes expressed in each sample
  
  * **J**: the total number of J genes

  * **VJ**: the total number of V-J gene combinations
  
  * **clone**: the number of unique clones

  * **clonotype**: the number of unique clonotypes


This slot can be extracted using the `mData()` function.

```{r sdata,  echo = T, eval=F}
mData(RepSeqData)
```

```{r view metaData, echo = F}
knitr::kable(mData(RepSeqData)) %>% 
     kableExtra::kable_styling(bootstrap_options = "condensed", 
                     full_width = F, 
                     position = "left",
                     font_size = 10)  %>%
  kableExtra::row_spec(0, color="#022f5a", font_size = 12)
 
```

- **otherData**: a list encompassing the output of a defined set of functions.

As the `outFiltered` parameter was set to TRUE during the RepSeqExperiment generation, filtered sequences are stored in this slot and can be viewed as followed.  

```{r odata,  echo = T, eval=F}
oData(RepSeqData)$filtered
```

```{r view otherData, echo = F}
knitr::kable(head(oData(RepSeqData)$filtered)) %>% 
     kableExtra::kable_styling(bootstrap_options = "condensed", 
                     full_width = F, 
                     position = "left",
                     font_size = 10)  %>%
  kableExtra::row_spec(0, color="#022f5a", font_size = 12)
 
```

This slot can be extracted using the `oData()` function.

- **History**: a data frame registering all operations performed on the RepSeqExperiment object, such as the filtering and the down-sampling.

This slot can be extracted using the `History()` function.

```{r history,  echo = T, eval=F}
History(RepSeqData)
```

```{r view history, echo = F}
knitr::kable(History(RepSeqData)) %>% 
     kableExtra::kable_styling(bootstrap_options = "condensed", 
                     full_width = F, 
                     position = "left",
                     font_size = 12) 
```

### RepSeqExp merging

`mergeRepSeq()` allows to combine two RepSeqExperiment objects encompassing different datasets. As such, a same **sample_id** cannot be in both datasets and should be renamed before using this function.

# Data manipulation

Different functions were developed to manipulate, filter, and normalize samples within a RepSeqExperiment object.

## Filtering

+ **Filter out sequences based on their count in each sample**

  `filterCount()` filters out sequences having a count below the chosen threshold. The function returns a RepSeqExperiment object that can be used to perform in-depth analyses on the remaining dataset

+ **Extract sequences that are either shared across samples, or private to a single sample**

  `getPublic()` allows to subset a RepSeqExperiment object in order to keep sequences that are shared by: 

    + samples belonging to a specified group
    + samples within the whole dataset if the `group` parameter is not specified.
  <br>

The function returns a RepSeqExperiment object with the selected clones.

```{r getoverlaps,  echo = T, eval=F}
# Get clones present in at least 50% of the samples belonging to the amTreg group
getPublic(x=RepSeqData, level="clone", group=c("cell_subset", "amTreg"))
```

  Similarly, it is possible to extract private sequences with `getPrivate()`. If the parameter `singletons` is set to TRUE, only private sequences with a count of 1 will be returned.

**Note**: All the above-mentioned functions can be applied at any of the following repertoire level: **clone**, **clonotype**, **CDR3aa** and **CDR3nt**.

+ **Filter out one or multiple sequence(s)**

  `filterSequence()` filters out specified sequences in all samples or a specified group of samples.

+ **Extract most frequent sequences**
  
  `getTopSequences()` allows the extraction of the top most expressed repertoire levels.
   Users can choose the proportion of the top sequences to extract using the `prop` parameter as well as the group of samples to analyze.

+ **Filter productive or unproductive sequences **

  `getProductive()` and `getUnproductive()` allow the extraction of productive and unproductive sequences respectively in case no filters were applied during the building of the RepSeqExperiment object.

+ **Exclude one or multiple samples from a RepSeqExperiment object**

  `dropSamples()` offers the possibility to filter out one or multiple repertoires by specifying their corresponding sample_id. 
 These repertoires can be ones identified as outliers during the exploratory analysis routine described further below.
 
## Normalization

**AnalyzAIRR** proposes two normalization strategies:

+ **Down-sampling**

This strategy can be applied when the studied samples largely differ in their repertoire sizes.

By using the `sampleRepSeqExp()` function, users can choose the value to which all the samples are downsampled. If not specified, the lowest number of sequences across the dataset will be used.
This function returns a new RepSeqExperiment object with the downsized data.

```{r downsample, echo=T, eval=F}
RepSeqData_ds<- sampleRepSeqExp(x=RepSeqData, sample.size=50000)
```

+ **Shannon-based normalization**

This strategy adapted in (Chaara et al., 2018) can be used to eliminate âuninformativeâ sequences resulting from experimental noise. It is particularly efficient when applied on small samples as it corrects altered count distributions caused by a high-sequencing depth.

The function `ShannonNorm()` allows the application of this strategy without the need to specify any parameter and returns a new RepSeqExperiment object with the corrected data.

```{r shannon norma, echo=T, eval=F}
RepSeqData_sh<- ShannonNorm(x=RepSeqData)
```

Eliminated sequences in each sample are stored in the **otherData** slot.

# Exploratory analysis

Data characterization can be performed using different exploratory functions proposed by **AnalyzAIRR**.

## Descriptive statistics

+ **Visualize the metaData statistics**

Statistics in the **metaData** slot, calculated during the building of the RepSeqExperiment object, can be visualized for each sample using the `plotStatistics()` function with the parameter `groupBy` set to NULL.

<div class="column-left">
```{r sd1, fig.cap="Figure 1: A barplot showing the number of TCR sequences identified in each sample."}
plotStatistics(x = RepSeqData,
               stat = "nSequences",
               groupBy = NULL)
```
</div>
<div class="column-right">
```{r sd2,fig.cap="Figure 2: A barplot showing the number of clonotypes identified in each sample."}
plotStatistics(x = RepSeqData,
               stat = "clonotype",
               groupBy = NULL)
```
</div>
</div>

+  **Calculate the count or the proportion of a chosen repertoire level**

   `countFeatures()` returns the calculated values for all the samples within the RepSeqExperiment object.

   The function takes into account the weight of the studied level, i.e. the number of sequences expressing a specific gene segment, or the count of a sequence in a sample.

```{r countFeatures, echo=TRUE, eval=FALSE}
countFeatures(x=RepSeqData, level="J", scale="frequency")

```

```{r, show countFeatures table, echo=F}
knitr::kable(countFeatures(RepSeqData, level="J", scale="frequency")) %>%
     kableExtra::kable_styling(bootstrap_options = "condensed",
                     full_width = F,
                     position = "left",
                     font_size = 10) %>%
    kableExtra::row_spec(0, color="#022f5a", font_size = 12) %>%
   kableExtra::scroll_box(width = "100%", height = "200px")
```

## Diversity estimation

+  **Rarefaction analysis** 

   Species richness can be assessed by a rarefaction table generated using the `rarefactionTab()` function.
   
   Rarefaction curves can as well be plotted using `plotRarefaction()`. The `colorBy` parameter is used to assign colors to plotted curves based on any group column from the **metaData** slot.
```{r plot rarefaction, echo=T, fig.width=8,fig.height=4, fig.align="center"}
plotRarefaction(x=RepSeqData, colorBy="sample_id")
```
<figcaption align = "center"><em class="special">Figure 3: Rarefaction curves plotting the number of clonotypes against the number of sequences in each sample.</em></figcaption>
<br>

+  **Calculation of diversity indices**

   The function `diversityIndices()` computes a set of diversity indices on a chosen repertoire level for each sample. The calculated indices are the following:

   - **Shannon index**: Calculates the proportional abundance of species in a repertoire (Shannon, 1948).

   - **Simpson index**: a measure taking into account the number of species present as well as their abundance. It gives relatively little weight to the rare species and more weight to the frequent ones (Simpson, 1949).

   - **Inverse Simpson index**: Is the effective number of species that is obtained when the weighted arithmetic mean is used to quantify average proportional abundance of species.

   - **Berger-Parker index**: Expresses the proportional importance of the most abundant species. This metric is highly biased by sample size and richness (Berger and Parker 1970).

   - **Gini coefficient**: Measures the degree of inequality in a distribution of abundances (Gini, 1921).

   - **Chao1**: Estimates undetected species using the information on the rarest species (the numbers of singletons and doubletons) (Chao, 1984).

   - **Improved Chao1**: An extension of **Chao1** which uses additional information, namely, the numbers of tripletons and quadrupletons  (Chiu et al., 2014).

```{r indices, echo = TRUE, eval=F}
diversityIndices(x=RepSeqData, level="clone")

```
```{r indices bis, echo = FALSE}
indices<- diversityIndices(x=RepSeqData, level="clone")
```

```{r view indices, echo = F}
knitr::kable(indices) %>%
     kableExtra::kable_styling(bootstrap_options = "condensed",
                     full_width = F,
                     position = "left",
                     font_size = 10)  %>%
  kableExtra::row_spec(0, color="#022f5a", font_size = 12)
```

The calculated indices can be plotted using `plotDiversity()`. The parameter `index` allows to choose which index is to be plotted.

If `groupBy` is not specified, calculated values in each sample are represented.

<div class="column-left">
```{r plot indices 1,fig.cap="Figure 4: A barplot showing the Gini values calculated at the clone level within each sample."}
plotDiversity(x=RepSeqData,
              level = "clone",
              groupBy = NULL,
              index = "gini")

```
</div>
<div class="column-right">
```{r plot indices 2,fig.cap="Figure 5: A barplot showing the Shannon values calculated at the clonotype level within each sample."}
plotDiversity(x=RepSeqData,
              level = "clonotype",
              groupBy = NULL,
              index = "shannon")
```
</div>

+  **Evaluation of the Renyi diversity**

   The Renyi index is a generalization of the Shannon entropy. 
  
  It represents the distribution of clonal expansions as a function of the parameter alpha. It equally considers all species including the rare ones at alpha=0, and up-weighs the abundant species with an increasing value of alpha. Alpha =1 is an approximation of the Shannon index; alpha = 2 corresponds to the Simpson index and alpha=Inf corresponds to the Berger-Parker index. The latter highlights the highest clonal expansion in a repertoire.


   Renyi values can be computed at any repertoire level using `renyiIndex()`.
By default, it is assessed for the following alpha values: $$\alpha \in {0, 0.25, 0.5, 1, 2, 4, 8, 16, 32, 64, Inf}$$

```{r renyi, echo = TRUE, eval=F}
renyiIndex(x=RepSeqData, level="clone")

```
```{r renyi bis, echo = FALSE}
rn<- renyiIndex(x=RepSeqData, level="clone")
```

```{r view renyi, echo = F}
knitr::kable(rn) %>%
     kableExtra::kable_styling(bootstrap_options = "condensed",
                     full_width = F,
                     position = "left",
                     font_size = 10)  %>%
  kableExtra::row_spec(0, color="#022f5a", font_size = 12)
```

  Renyi's entropy values can be plotted using `plotRenyiIndex()`. If the `grouped` parameter is set to **FALSE**, a curve for each sample is plotted and colors are attributed based on the `colorBy` parameter. 

```{r plot renyi, echo = TRUE, fig.width=8, fig.height = 4,fig.align="center"}
plotRenyiIndex(x=RepSeqData, level="J", grouped=FALSE, colorBy = "sample_id")
```
<figcaption align = "center"><em class="special">Figure 6: The Renyi values were calculated at the J gene level at each pre-defined alpha value and plotted for each sample.</em></figcaption>

## Clonal distribution

+ **Clonal distribution within count intervals**

  The `plotCountIntervals()` function can be used to assess the clonal distribution within pre-defined count intervals.

  It computes:

  - The proportion that a defined repertoire level within each count interval represents in the total repertoire, thus giving a global evaluation of the count distribution.
  - The cumulative frequency of a defined repertoire level within each count interval thus giving the proportion that each interval occupies in the repertoire.

```{r intervals, fig.height=6, fig.width=7,fig.align="center"}
plotCountIntervals(x=RepSeqData, level="clone")
```
<figcaption align = "center"><em class="special">Figure 7: Stacked bars showing the distribution (upper plot) and the cumulative frequency (lower plot) of clones within each count interval in each sample.</em></figcaption>
<br>

+ **Clonal Distribution per decreasing rank**

 Another way to assess the clonal distribution is by visualizing the distribution as a function of the ranks.
 Samples can be colored by **sample_id** as well as by any group column from the `mData()` slot.

```{r plot clone distri, echo = TRUE, warning=FALSE,fig.width=8, fig.height =4,fig.align="center"}
plotRankDistrib(x=RepSeqData,level="clone", colorBy="sample_id", grouped=F, scale="frequency")
```
<figcaption align = "center"><em class="special">Figure 8: Clonal distribution as a function of the occurrence rank for each sample.</em></figcaption>
<div>

# One-sample analysis 

Descriptive analyses of each repertoire can be performed individually.
These analyses include the ones previously described as well as other metrics.
In all the following functions, the **sample_id** of interest needs to be specified in the `sampleName` parameter. If not specified, the first **sample_id** in the dataset will be analyzed

+ **Assess the clonal distribution per count intervals**

   `plotIndCountIntervals()` allows the analysis of the clonal distribution per count interval in a single sample.

```{r plotIndCountIntervals, echo=TRUE,message=FALSE, warning=FALSE,fig.width=7, fig.height = 4,fig.align="center", cache.comments=FALSE}
plotIndCountIntervals(RepSeqData,level = "clone", sampleName="tripod-30-813")
```
<figcaption align = "center"><em class="special">Figure 9: Barplots showing the distribution (upper plot) and the cumulative frequency (lower plot) of clones within each count interval for one selected sample.</em></figcaption>
<br>

+ **Analyze V and J gene usages**

    `plotIndGeneUsage()`computes V or J gene usages.
  The parameter `scale` allows to choose whether to compute the count or the frequency.
```{r J usage ind, echo = TRUE, message=F,warning=F,fig.height = 4,fig.width= 8,fig.align="center"}
plotIndGeneUsage(x=RepSeqData, level="J", scale="frequency")
```
<figcaption align = "center"><em class="special">Figure 10: Barplots showing the frequency of each J gene in one selected sample.</em></figcaption>
<br>
   V-J combination usages can as well be analyzed using the `plotVJusage()` function.
   Users can choose whether to plot the top most used combinations using the `prop` parameter or all combinations expressed in a sample. Two types of visualizations are proposed, either a **Heatmap** or a **Circos** plot and which can be specified in the `plot` parameter. 

```{r VJusage, fig.align="center",fig.width=5, fig.height=4, warning=F, message=F,cache.comments=FALSE}
#Plot the top 1% VJ combinations
plotVJusage(x=RepSeqData, scale = "frequency", prop=0.01, plot="Circos")
```
<figcaption align = "center"><em class="special">Figure 11: A circos plot showing the 1% most frequent VJ combinations in one selected sample.</em></figcaption>
<br>

+ **CDR3 Spectratyping**

Spectratyping analyzes the CDR3 amino acid length distribution in a sample.

Using `plotSpectratyping()`, it is possible to add V gene usage information per CDR3 length. The proportion of the most used genes within the repertoire can be specified with the `prop` parameter, thus showing their relative proportions within each CDR3 length.

```{r spectra, fig.width=8, fig.height = 4,fig.align="center"}
#Show the top 10%
plotSpectratyping(x=RepSeqData, scale = "frequency", prop=0.1)
```
<figcaption align = "center"><em class="special">Figure 12: CDR3 spectratyping for one selected sample. The 10% most frequent V genes are distinctively coloured.</em></figcaption>
<br>
On the other hand, `plotSpectratypingV()` draws the length distribution for each V gene individually.
```{r spectraV, fig.height = 3.5,fig.width=8,fig.align="center"}
plotSpectratypingV(x=RepSeqData, scale = "frequency",prop=0.1)
```
<figcaption align = "center"><em class="special">Figure 13: CDR3 spectratyping for the top 10% V genes in one selected sample.</em></figcaption>

# Multi-sample analysis

## Comparison of descriptive statistics 

The majority of the functions described in [the Exploratory analysis section](#Exploratory) can be applied to compare groups of samples and perform statistical tests.

+ **Compare metaData statistics**

   The calculated statistics in the **metaData** slot can be compared between groups of samples. This is possible using the `plotStatistics()` function by specifying one or multiple group columns from the **metadata** slot in the `groupBy` parameter. 
   
   In case multiple groups are specified, the first group will be compared and the others will be used as facets.

<div class="column-left">
```{r comp sd1,fig.cap="Figure 14: Comparison of the the number of clonotypes between amTreg and nTreg samples. Boxplots represent the median across all samples belonging to the same group. A Wilcoxon test is applied and adjusted p-values using the Holm method are shown."}
plotStatistics(x = RepSeqData,
               stat = "clonotype",
               groupBy = "cell_subset")
```
</div>
<div class="column-right">
```{r comp sd2,fig.cap="Figure 15: Comparison of the the number of clonotypes between amTreg and nTreg samples within each sex. Boxplots represent the median across all samples belonging to the same specified group. A Wilcoxon test is applied and adjusted p-values using the Holm method are shown."}
plotStatistics(x = RepSeqData,
               stat = "clonotype",
               groupBy = c("cell_subset", "sex"))
```
</div>

<br>

+ **Compare gene usage**

  `plotGeneUsage()` allows the comparison of V or J gene usages between groups of samples using the `groupBy` parameter

```{r J usage , echo = TRUE, fig.width=12, fig.height=3.5, message=F,warning=F,fig.align="center"}
plotGeneUsage(x=RepSeqData, level="J", scale="frequency", groupBy="cell_subset")
```
<figcaption align = "center"><em class="special">Figure 16: Comparison of the J gene usage between amTreg and nTreg samples. A Wilcoxon test was performed. Only significant values are plotted.</em></figcaption>
<br>

+ **Compare repertoire diversities**

   The `plotDiversity()` function also supports the `groupBy` parameter to compare groups for a chosen diversity index.

<div class="column-left">
```{r plot indices 3, fig.cap="Figure 17: The Gini index is calculated at the clone level and compared between cell subsets. Boxplots represent the median across all samples belonging to the same group. A Wilcoxon test is applied and adjusted p-values using the Holm method are shown." }
plotDiversity(x = RepSeqData,
              level = "clone",
              groupBy = "cell_subset",
              index = "gini")

```
</div>
<div class="column-right">
```{r plot indices 4, fig.cap="Figure 18: The Gini index is calculated at the clone level and compared between cell subsets within each sex. Boxplots represent the median across all samples belonging to the same group. A Wilcoxon test is applied and adjusted p-values using the Holm method are shown." }
plotDiversity(x = RepSeqData,
              level = "clone",
              groupBy = c("cell_subset","sex"),
              index = "gini")

```
</div>
<br>

  For the Renyi index, the `grouped` parameter should be set to **TRUE**, and the groups to be analysed should be specified in the `colorBy` parameter.

```{r plot plotRenyiIndexG, fig.height = 5, fig.width=7, fig.align='center'}
plotRenyiIndex(x = RepSeqData,
                  level = "clone",
                  grouped = "TRUE",
                  colorBy = c("cell_subset","sex"))

```
<figcaption align = "center"><em class="special">Figure 19: The Renyi values were calculated at the clone level at each pre-defined alpha value. For each specified group, the mean (circles) and stantard error (shade) are plotted. The area under the curve (AUC) is calculated for each sample and compared between chosen groups using a Wilcoxon test with Holm's correction.</em></figcaption>

<br><br>

+ **Compare clonal distributions**

   Similarly to the analysis applied at the single-sample level, `plotCountIntervals()` allows to plot and compare clonal distributions within defined count intervals between experimental groups.

```{r plotDistribVpJall,fig.height = 5, fig.width=7, fig.align='center'}
plotCountIntervals(x=RepSeqData, level="clone", groupBy = c("cell_subset","sex"))
```
<figcaption align = "center"><em class="special">Figure 20: The distribution (upper plot) and the cumulative frequency (bottom plot) of clones within each count interval was compared between amTreg and nTreg samples within each sex. A Wilcoxon test is applied and adjusted p-values using the Holm method are shown.</em></figcaption>


## Similarity analysis

The repertoire sharing at any level evaluates the degree of convergence between repertoires and experimental conditions.
Different statistical methods are proposed herein to evaluate this convergence.

 + **Compute the number of shared sequences**

   The number of shared sequences, at any level, between samples belonging for instance to the same experimental group can be obtained using the `plotVenn()` function.
  If `sampleNames` is not specified, the first 3 samples in the datasets will be analyzed.

```{r venn, fig.align='center',echo = T, eval=T,  fig.width=8, fig.height=4}
ctrnames <- rownames(mData(RepSeqData))[which(mData(RepSeqData)[,"cell_subset" ] %in% "nTreg")]
plotVenn(x = RepSeqData,
           level = "clone",
           sampleNames = ctrnames)
```
<figcaption align = "center"><em class="special">Figure 21: Venn diagram representing the number of shared clones between the nTreg samples.</em></figcaption>
<br>

+ **Assess the correlation between a pair of samples**

  The correlation between a pair of repertoires can be calculated using the `plotScatter()` function by simply specifying a pair of `sampleNames` to compare.

<div class="column-left">
```{r scatter, echo = T, eval=T, message=FALSE, fig.cap="Figure 22: A biplot comparing the V gene usage between two defined samples. A linear model is fitted on the data. The V usage is significantly similar between the two samples."}
plotScatter(x = RepSeqData,
            level = "V",
            scale = "frequency",
            sampleNames = c("tripod-30-813","tripod-31-846"))
```
</div>

<div class="column-right">
```{r scatter 2, echo = T, eval=T, message=FALSE, fig.cap="Figure 23: A biplot comparing the clonal expression between two defined samples. A linear model is fitted on the data. Clonal overlap and expression are significantly low between the compared samples."}
plotScatter(x = RepSeqData,
            level = "clone",
            scale = "frequency",
            sampleNames = c("tripod-30-813","tripod-31-846"))
```
</div>

+ **Compute dissimilarity distances**

   **AnalyzAIRR** proposes a list of dissimilarity indices, each taking into account different parameters. The proposed methods include:

   + The **Jaccard** similarity: a measure of similarity between sample sets defined as the size of the intersection divided by the size of the union of the sample sets.

   + The **Morisita-Horn** similarity: a measure of similarity that tends to be over-sensitive to abundant species.

   Details on these indices and others can be found [here](https://rdrr.io/cran/vegan/man/vegdist.html)

  These distances can be calculated at any level of the repertoire and can be:

    - Visualized As a dissimilarity heatmap by setting `plot` to **Heatmap**.
  This function performs a hierarchical clustering on the calculated distance scores using the method specified in  the `clustering` parameter.
    - Used to perform a multidimensional scaling analysis by setting `plot` to **MDS**. In this case, no clustering method is needed.

<div class="column-left">
```{r dissimilarity, echo = TRUE, fig.cap="Figure 24: A heatmap showing the Morisita distances calculated at the clone level between all pairwise samples. The ward D method was used to perform the hierarchical clustering."}
plotDissimilarity(x = RepSeqData,
                  level = "clone",
                  method = "morisita",
                  clustering = "ward.D",
                  colorBy = c("sex","cell_subset"),
                  plot="Heatmap")
```
</div>

<div class="column-right">
```{r mds1, echo = TRUE,warning=FALSE, message=FALSE, fig.cap="Figure 25: Morisita distances were calculated at the clone level between all pairwise samples within the dataset and used to perform a multidimensional scaling analysis."}
plotDissimilarity(x = RepSeqData,
                 level = "clone",
                 method = "morisita",
                 colorBy = "cell_subset",
                 plot="MDS"
                 )
```
</div>
<br><br>

## Differential analysis

 Differentially expressed genes or sequences can be identified using `diffExpGroup`.
The experimental groups to be compared can be specified with the `group` parameter, and the function outputs the statistics calculated for each gene/sequence.

In the following example, we identify over-expressed VJ combinations within the amTreg samples compared to the nTregs.

```{r diffexp, warning=FALSE, message=FALSE}
DS <- diffExpGroup(x = RepSeqData,
                   colGrp = "cell_subset" ,
                   level = "VJ",
                   group = c("cell_subset", "amTreg", "nTreg"))
```
```{r dds, echo = F, warning=FALSE, message=FALSE,fig.width=5, fig.height=3.5}

knitr::kable(DS) %>%
   kableExtra::kable_styling(bootstrap_options = "condensed",
                    full_width = FALSE,
                    position = "left",
                    font_size = 10) %>%
  kableExtra::row_spec(0, color="#022f5a", font_size = 12) %>%
   kableExtra::scroll_box(width = "100%", height = "200px")

```

<br>

The results can be visualized using the `plotDiffExp` function into a volcano plot.

   Users can specify the number of top differentially expressed genes/sequences to be identified on the plot using the `top` parameter.
   It is also possible to choose a log2FoldChange and an adjusted pvalue threshold, based on which the over- and down-expression will be defined. By default, these parameters are fixed to 2 and 0.05 respectively.

```{r volcano, echo = TRUE, warning=FALSE, message=FALSE,fig.width=7, fig.height=4,fig.cap="Figure 26: A volcano plot showing differentially expressed VJ combinations between amTreg and nTreg samples. Over-expressed combinations in the amTreg population are shown in red."}
plotDiffExp(x = RepSeqData,
            top = 10,
            level = "VJ",
            group = c("cell_subset", "amTreg", "nTreg"))
```


## Spectratyping comparison

 `perturbationScore()` function computes the perturbation scores of the CDR3aa length distribution within each V gene as a distance between each repertoire and the mean repertoire of the control group.

```{r, echo=TRUE, eval=FALSE}
ctrnames <- rownames(mData(RepSeqData))[which(mData(RepSeqData)[,"cell_subset" ] %in% "nTreg")]
perturbationScore(RepSeqData, ctrl.names=ctrnames, distance ="euclidean")

```

```{r deseq2.res 2, echo = F, include = TRUE}
ctrnames <- rownames(mData(RepSeqData))[which(mData(RepSeqData)[,"cell_subset" ] %in% "nTreg")]
per<- perturbationScore(RepSeqData, ctrl.names=ctrnames, distance ="euclidean")
knitr::kable(per) %>%
   kableExtra::kable_styling(bootstrap_options = "condensed",
                    full_width = FALSE,
                    position = "left",
                    font_size = 10) %>%
  kableExtra::row_spec(0, color="#022f5a", font_size = 12) %>%
   kableExtra::scroll_box(width = "100%", height = "200px")
```

<br>
 Scores can be visualized in a heatmap using the `plotPerturbationScore()` function.

The parameter `order` allows to define the order in which the samples will be plotted on the heatmap which helps a better separation between the control groups and the other samples.

```{r, echo=T,warning=F, message=F, fig.width=8, fig.height=4, fig.align='center'}
plotPerturbationScore(RepSeqData, ctrl.names=ctrnames, distance ="euclidean", order="cell_subset")

```
<figcaption align = "center"><em class="special">Figure 28: A heatmap plotting the perturbation scores of the CDR3aa length distribution within each V gene in the amTreg population compared to the nTregs (used as reference). The parameter order allows to define the order in which the samples will be plotted on the heatmap which helps a better separation between the control groups and the other samples.</em></figcaption>

